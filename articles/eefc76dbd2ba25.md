---
title: "【Flutter】アーキテクチャを0から考えてアプリを作り直した話"
emoji: "😎"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Flutter", "Dart", "アーキテクチャ", "設計"]
published: false
---

ここ半年ほど、仕事で Flutter アプリを 0 から作り直しています。

ちょうど今年の個人的なテーマを「アーキテクチャ」に据えていたこともあり[^1]、またその一環として [「Clean Architecture 達人に学ぶソフトウェアの構造と設計」](https://www.amazon.co.jp/dp/4048930656) （以下：クリーンアーキテクチャ本）を読んでいたこともあり、この作り直しでは「アーキテクチャ」をしっかりと自分の頭で考えて作ろうと決めて取り組んできました。

https://www.amazon.co.jp/dp/4048930656

アーキテクチャについて頭を悩ませながら実装を進めること約半年、ようやくアプリが形になるとともにある程度知見も溜まってきましたので、その知見を一般化した内容をこの記事にまとめていきたいと思います。

# 注意

この記事は、「Flutter アプリのアーキテクチャはこれがベストプラクティス！」という類の記事ではありません。あくまで __自分の目の前の要件ではこれが最適と判断した__ という一例の紹介になります。

ここに書く内容はどのようなアプリでもそのまま適用してうまくいくものではありません。クリーンアーキテクチャ本でも強調されている（と私は理解している）ように、 __それぞれのソフトウェアの開発者がそれぞれの要件や状況を考慮した上でその時点での最適なアーキテクチャを考え続ける__ のが大事だと思っています。

安易に「このパターンに当てはめればうまくいくだろう」と考えてはいけないことを念頭にこの記事を読んでいただければと思います。この記事で紹介するアーキテクチャも、何か具体的なパターンに必要以上に引っ張られないように意識して考えています。[^2]

# アプリの主な要件
アーキテクチャの話に入る前に、開発中のアプリがどのような要件なのかを説明します。具体的なアプリ名や内容までは書けないので、アーキテクチャの検討に強く影響している要素を列挙します。

### バックエンド（今回は Firestore）に保存したデータを取得して画面に表示するパターンが多め

いわゆる「JSON に色を付ける」程度で事足りる機能が 6 割程度を占めます。ただし、いくつかの機能では複数のコレクションからデータを引っ張ってマージしたりする必要があったり、また取得したデータをアプリ内で実装したロジックに従って一度変換してから UI に表示するような機能もあります。逆に保存すべきデータをアプリ内に実装したロジックで生成しなければならない機能もあります。

つまり、データをそのまま入出力する「だけ」とは言えないが、一方で込み入ったシステムがアプリ内に必要なわけでもない、という温度感です。

### リアルタイムなデータ共有を積極的に利用する

アプリのメインとなるのが「複数人でリアルタイムに共有することで価値が出る」類の機能です。そのため、Firestore のリアルタイムアップデートを利用する場面が多いです。

### 「似たような機能を持った別アプリ」の開発・リリースを念頭におく

今回開発したアプリを元に、ターゲットを変更した別アプリや、一部の機能のみを抽出して特化させたアプリの開発を念頭に置く、というのも大事な要件のひとつです。そのため、コードは可能な限り共通利用できる形で設計することが求められます。

### GPS を利用するため机上で開発・デバッグしづらい

このアプリは GPS を利用した機能を中心としています。そのため、机上での開発には GPS をモックする機能が必要になるのですが、GPS をモックするには Android / iOS それぞれに一手間が必要だったり制約があったりします。[^3]

# 全体を 3 つのレイヤーに分ける

## メリット
- 再利用性
- テストのしやすさ
- 実装時の役割分担のしやすさ

## どんなプラットフォームでもやり遂げたいことを担当する BusinessLogic

- BusinessLogic は __どんなプラットフォームでも、なんならアプリがなくてもやりたいこと__ を担当します。
- 「たとえば、Zenn から Flutter の Riverpod に関する記事を探したい」要件があった場合
  - Zenn のすべての記事を並べて
  - 「Flutter の Riverpod パッケージ」に言及する記事かそうでないかを判断し
  - 該当する記事のみを書き出していく
- という作業はどんなプラットフォームでも、なんならアプリがなくても手作業でできる。
- BusinessLogic はこの「データを取ってきて、必要なものを取捨選択して、目当てのデータのみを集めたリストを作成する、という処理を書くことになる。
- View をどのようなプラットフォームで実装したとしても、 Repository がどのデータベースからどのようにデータを取得したとしても BusinessLogic は使いまわせるようにする。

## データの出し入れをする Repository
- Repository では __データを出し入れする__ 処理を担当する。
- データの出し入れには、以下の具体的な情報を必要とする
  - どのデータベースから
  - どのようにクエリを投げて
  - どのように結果セットをプログラムで扱えいやすい形に変換するのか
- 具体的なデータベース製品やその仕様、データ構造の都合はすべてこのレイヤーで吸収し、BusinessLogic には BusinessLogic が一番使いやすい形に成形したオブジェクトを返却する。
  - たとえば、 `DocumentReference` や `DocumentSnapshot` といった __Firestore を使っているからこそ登場するオブジェクトは持ち込んではいけない__

## 入出力を担当する View

- View は入出力を担当する
  - ユーザーが入力したものを BusinessLogic にわたし、
  - BusinessLogic が生成したデータをユーザーにわかる形で出力する。
  - Flutter アプリの場合、Flutter パッケージに依存するのはこのレイヤーのみ
- UI に関する事情（アニメーションや画面遷移など）は全てここで解決する。
  - 画面遷移に合わせて BusinessLogic クラスを分けてはいけない。
  - 画面遷移に合わせて Repository クラスを分けてもいけない

## その他

- 「データクラス」は独立したレイヤーとして扱う
- 汚れ役は `main.dart` で
- GPS の取得は Repository 層で。
- interface は「使う側」のレイヤーに（依存性の逆転）
- 「データを生成する系」のパッケージの考え方（GPSなど）

[^1]: 去年は「Flutter の内部実装」でした。

[^2]: ですので、「この設計、〇〇パターンのこの原則に違反してるじゃん」「この用語、△△パターンでの定義と違うじゃん」というような批判はご遠慮ください。そもそもそのようなパターンに準拠することを目的としていません。

[^3]: 実機で使えない、任意の位置情報をシミュレートできない、など。